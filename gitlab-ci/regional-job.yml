# Dynamic Regional Jobs using GitLab Child Pipelines (Shell Version)
# This approach generates region-specific jobs dynamically based on REGIONS variable
# Uses pure shell script - no Node.js dependencies

# Job to generate dynamic pipeline configuration using shell
generate-regional-pipeline:
  stage: pre
  image: alpine:latest
  services: []
  before_script:
    - echo "Starting regional pipeline generation..."
  script:
    - |
      if [ -z "$REGIONS" ]; then
        echo "Error: No REGIONS environment variable found"
        echo "Example: REGIONS='th,sg,my,jp'"
        exit 1
      fi

      # Ensure 'hk' is present in REGIONS
      if [ "$DEV_PIPELINE" != "true" ]; then
        if ! echo ",$REGIONS," | grep -q ",hk,"; then
          REGIONS="$REGIONS,hk"
        fi
      fi

      echo "ğŸš€ Generating pipeline for regions: $REGIONS"

      # Create the generated pipeline file
      cat > generated-regional-pipeline.yml << EOF
      # Auto-generated regional pipeline
      # Generated for regions: $REGIONS

      stages:
        - regional-build
        - regional-deploy

      EOF

      # Convert comma-separated regions to array (Alpine compatible)
      OLD_IFS="$IFS"
      IFS=','
      set -- $REGIONS
      IFS="$OLD_IFS"

      job_count=0

      for region in "$@"; do
        # Remove whitespace
        region=$(echo "$region" | tr -d ' ')

        if [ -n "$region" ]; then
          job_count=$((job_count + 2))

          # Generate build job
          cat >> generated-regional-pipeline.yml << EOF
      ${region}-build-docker:
        stage: regional-build
        image: docker
        services:
          - docker:dind
        variables:
          REGION_NAME: "$region"
          DOCKER_BUILDKIT: "1"
        before_script:
          - unset DOCKER_AUTH_CONFIG
          - apk add --update docker-cli-buildx
          - docker version && docker buildx version || true
          - docker buildx create --use --name gcrbuilder --driver docker-container || docker buildx use gcrbuilder
          - docker buildx inspect --bootstrap
          - echo \$GCP_SERVICE_ACCOUNT > /root/key.json
          - docker login -u _json_key --password-stdin https://asia.gcr.io < /root/key.json
          - rm -rf /root/key.json
        script:
          - echo "Building for region $region"

          # buildxï¼šä½¿ç”¨ registry cache + inline cacheï¼Œä¸€æ¬¡æ¨å…©å€‹ tag
          - |
            docker buildx build \
              --pull \
              --push \
              --platform linux/amd64 \
              --build-arg BUILDKIT_INLINE_CACHE=1 \
              --cache-from=type=registry,ref=\$DOCKER_IMAGE_REPO:buildcache-$region \
              --cache-from=\$DOCKER_IMAGE_REPO:\$TAG-$region \
              --cache-to=type=registry,ref=\$DOCKER_IMAGE_REPO:buildcache-$region,mode=max \
              --cache-to=type=inline,mode=max \
              -t \$DOCKER_IMAGE_REPO:\$TAG-$region \
              -t \$DOCKER_IMAGE_REPO:\$CI_COMMIT_SHA-$region \
              --build-arg GIT_USERNAME="\$GIT_USERNAME" \
              --build-arg GIT_PASSWORD="\$GIT_PASSWORD" \
              --build-arg BUILD="\$BUILD" \
              --build-arg CI_COMMIT_SHA="\$CI_COMMIT_SHA" \
              --build-arg APP_ENV="\$APP_ENV" \
              --build-arg REACT_APP_REGION="$region" \
              --build-arg REGION="$region" \
              .

          # éœ€è¦ release tag æ™‚ï¼Œç›´æ¥åœ¨ registry ç«¯é‡ç”¨åŒä¸€å€‹ manifest
          - |
            if [ -n "\$CI_COMMIT_TAG" ]; then
              docker buildx imagetools create \
                -t \$DOCKER_IMAGE_REPO:\$CI_COMMIT_TAG-$region \
                \$DOCKER_IMAGE_REPO:\$CI_COMMIT_SHA-$region
            fi

          # è‹¥ç‚º hkï¼Œé¡å¤–å»ºç«‹ç„¡å°¾ç¢¼ tagï¼ˆåŒ digestï¼‰
          - |
            if [ "$region" = "hk" ]; then
              echo "Hong Kong region detected, adding unsuffixed tag"
              docker buildx imagetools create \
                -t \$DOCKER_IMAGE_REPO:\$TAG \
                \$DOCKER_IMAGE_REPO:\$TAG-$region
            fi
        rules:
          - if: '\$BUILD'

      EOF
        fi
      done

      echo "âœ… Generated $job_count jobs for regions: $REGIONS"
      echo "ğŸ“„ Pipeline written to: generated-regional-pipeline.yml"

      # Show the generated content for debugging
      echo "ğŸ“‹ Generated pipeline preview:"
      head -20 generated-regional-pipeline.yml
  artifacts:
    paths:
      - generated-regional-pipeline.yml
    expire_in: 1 hour
  rules:
    - if: '$REGIONS && $BUILD'

# Trigger the dynamically generated regional pipeline
trigger-regional-jobs:
  stage: pre
  needs:
    - generate-regional-pipeline
  trigger:
    include:
      - artifact: generated-regional-pipeline.yml
        job: generate-regional-pipeline
    strategy: depend
  rules:
    - if: '$REGIONS && $BUILD && $TAG && $DOCKER_IMAGE_REPO'

.update-digests-base:
  stage: pre
  variables:
    GIT_DEPTH: "0"
  script: |
    set -eu
    apk add --no-cache git curl skopeo findutils
    curl -fsSL https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64 -o /usr/local/bin/yq
    chmod +x /usr/local/bin/yq

    # ç”¨ PAT æ”¹ remoteï¼Œé¿å… gitlab-ci-token

    git config --global user.name  "gitlab-ci"
    git config --global user.email "gitlab-ci@dimorder.com"
    git config --global --add safe.directory "$CI_PROJECT_DIR"
    git config --global credential.helper store
    printf "https://oauth2:%s@gitlab.com\n" "$GIT_PAT" > ~/.git-credential

    git remote set-url origin "https://oauth2:${GIT_PAT}@gitlab.com/${CI_PROJECT_PATH}.git"
    git push origin "HEAD:${CI_COMMIT_REF_NAME}"

    # å°‹æ‰¾ manifestï¼ˆæ²¿ç”¨ä½ åŸæœ¬é‚è¼¯ï¼‰
    pick_manifest() {
      for f in deployment.yaml deployment.yml deploy.yaml deploy.yml; do
        [ -f "$f" ] && { echo "$f"; return; }
      done
      root_glob="$(ls -1 deploy*.ya?ml 2>/dev/null | head -n1 || true)"
      [ -n "$root_glob" ] && { echo "$root_glob"; return; }
      found="$(find . -maxdepth 2 -mindepth 2 -type f \( -name 'deployment.ya?ml' -o -name 'deploy*.ya?ml' \) | head -n1 || true)"
      [ -n "$found" ] && { echo "$found"; return; }
      echo "ERROR: No manifest file found (deployment.yaml, deploy.yaml, etc.)"
      exit 1
    }

    MANIFEST="$(pick_manifest)"
    echo "Using manifest: $MANIFEST"

    if [ "${DEV_PIPELINE:-}" != "true" ]; then
      case ",${REGIONS}," in *",hk,"*) : ;; *) REGIONS="${REGIONS},hk" ;; esac
    fi

    # yq æœƒç”¨åˆ°çš„ç’°å¢ƒè®Šæ•¸ï¼š
    # MODE: auto / held
    # HOLD_SITES: é€—è™Ÿåˆ†éš”çš„ SimpleSite åç¨±
    export MODE="${MODE:-auto}"
    export HOLD_SITES="${HOLD_SITES:-}"

    changed=0
    IFS=','

    SKOPEO_ARGS="${SKOPEO_CREDS:-}"

    for raw in $REGIONS; do
      region="$(echo "$raw" | xargs)"
      [ -n "$region" ] || continue

      image_ref="${DOCKER_IMAGE_REPO}:${CI_COMMIT_SHA}-${region}"
      echo "Resolving digest for: ${image_ref}"
      digest="$(skopeo inspect ${SKOPEO_ARGS} --format '{{.Digest}}' "docker://${image_ref}")"
      [ -n "$digest" ] || { echo "ERROR: cannot resolve digest for ${image_ref}" >&2; exit 1; }
      echo "  -> digest: ${digest}"

      # names: å¾ HOLD_SITES è®Šæ•¸è½‰æˆé™£åˆ—ï¼ˆå»å‰å¾Œç©ºç™½ï¼‰
      # selector:
      #   MODE=held -> åªé¸åœ¨ HOLD_SITES è£¡çš„ SimpleSite
      #   MODE=auto -> æ’é™¤åœ¨ HOLD_SITES è£¡çš„ SimpleSite
      # åœ¨ for è¿´åœˆå…§ï¼Œæ‹¿åˆ° $region èˆ‡ $digest å¾Œï¼š
      REGION="$region" DIGEST="$digest" MODE="$MODE" HOLD_SITES="${HOLD_SITES:-}" \
      yq -i '
        . as $doc
        | ( (strenv(HOLD_SITES) // "" | select(. != "") | split(",") | map(sub("^\\s+|\\s+$"; ""))) // [] ) as $names
        | .metadata.name as $n
        | ($names | map(select(. == $n)) | length) as $cnt
        | (
            select( .kind == "SimpleSite" and
                    (
                      (env(MODE) == "held" and ($cnt > 0)) or
                      (env(MODE) != "held" and ($cnt == 0))
                    )
                  )
            | select(strenv(REGION) != "" and strenv(DIGEST) != "")
            | .spec.buildImages[strenv(REGION)] = strenv(DIGEST)
            | .spec.buildImages |= with_entries(select(.key != "" and .value != ""))
          ) // $doc
      ' "$MANIFEST"

      changed=1
    done

    # ArgoCD repoURL & rapid
    yq -i 'select(.kind == "SimpleSite") .spec.argocd.repoURL = "git@gitlab.com:'"${CI_PROJECT_PATH}"'.git"' "$MANIFEST"
    if [ -z "${CI_COMMIT_TAG:-}" ]; then
      yq -i 'select(.kind == "SimpleSite") .spec.argocd.rapid = true' "$MANIFEST"
    else
      yq -i 'select(.kind == "SimpleSite") .spec.argocd.rapid = false' "$MANIFEST"
    fi

    if [ "$changed" -eq 1 ]; then
      git add "$MANIFEST"
      # è¨Šæ¯ä¾æƒ…å¢ƒæ¨™ç¤º
      if [ "$MODE" = "held" ]; then
        git commit -m "chore(ci): release later sites -> write digests [skip ci]"
      else
        git commit -m "chore(ci): bump version [skip ci]"
      fi
      git push origin "HEAD:${CI_COMMIT_REF_NAME}"
      echo "Updated and pushed ${MANIFEST}"
    else
      echo "No changes to commit."
    fi

# -------------------------------------------------------
# ä¸€èˆ¬è‡ªå‹•æµç¨‹ï¼šæœƒè·³é HOLD_SITES
# -------------------------------------------------------
update-rollout-digests:
  extends: .update-digests-base
  needs: [trigger-regional-jobs]
  variables:
    MODE: "auto"   # é—œéµï¼šè‡ªå‹•æµç¨‹æ’é™¤ HOLD_SITES
  rules:
    - if: '$REGIONS && $BUILD && $TAG && $DOCKER_IMAGE_REPO && $CI_COMMIT_BRANCH != "beta"'
      exists:
        - deploy.yml
        - deployment.yaml
        - deploy.yaml
        - deployment.yml
    - when: never

# -------------------------------------------------------
# æ‰‹å‹•é‡‹å‡ºï¼šåªè™•ç† HOLD_SITES åˆ—è¡¨ï¼ˆrelease laterï¼‰
# -------------------------------------------------------
release-later:
  extends: .update-digests-base
  needs: [trigger-regional-jobs]
  variables:
    MODE: "held"   # é—œéµï¼šåªè™•ç† HOLD_SITES
  when: manual
  allow_failure: false
  rules:
    - if: '$REGIONS && $BUILD && $TAG && $DOCKER_IMAGE_REPO && $HOLD_SITES && $CI_COMMIT_BRANCH != "beta"'
      exists:
        - deploy.yml
        - deployment.yaml
        - deploy.yaml
        - deployment.yml
